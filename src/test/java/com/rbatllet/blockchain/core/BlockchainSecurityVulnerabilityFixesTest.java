package com.rbatllet.blockchain.core;

import com.rbatllet.blockchain.entity.AuthorizedKey;
import com.rbatllet.blockchain.util.CryptoUtil;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.security.KeyPair;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive security tests to verify all vulnerability fixes
 * Tests the security improvements implemented in the Blockchain class
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@DisplayName("ðŸ” Blockchain Security Vulnerability Fixes Verification")
class BlockchainSecurityVulnerabilityFixesTest {

    private static final Logger logger = LoggerFactory.getLogger(BlockchainSecurityVulnerabilityFixesTest.class);

    private Blockchain blockchain;
    private KeyPair adminKeyPair;
    private KeyPair userKeyPair;
    private String adminPublicKey;
    private String userPublicKey;

    @BeforeEach
    void setUp() {
        blockchain = new Blockchain();
        blockchain.clearAndReinitialize();

        // Create admin and user key pairs
        adminKeyPair = CryptoUtil.generateKeyPair();
        userKeyPair = CryptoUtil.generateKeyPair();
        adminPublicKey = CryptoUtil.publicKeyToString(adminKeyPair.getPublic());
        userPublicKey = CryptoUtil.publicKeyToString(userKeyPair.getPublic());

        // Add admin as authorized key
        blockchain.addAuthorizedKey(adminPublicKey, "Administrator");
        blockchain.addAuthorizedKey(userPublicKey, "TestUser");
    }

    @AfterEach
    void tearDown() {
        blockchain.completeCleanupForTests();
    }

    @Nested
    @DisplayName("ðŸ”’ FIX 1: Block Size Validation Consistency")
    class BlockSizeValidationConsistencyFix {

        @Test
        @Order(1)
        @DisplayName("validateBlockSize should use consistent byte-based validation")
        void testConsistentBlockSizeValidation() {
            // Test 1: Small data should always pass
            assertTrue(blockchain.validateBlockSize("Small data"),
                "Small data should pass validation");

            // Test 2: Large multibyte characters should be handled correctly
            String multibyte = "æµ‹è¯•".repeat(100000); // Chinese characters, 3 bytes each
            byte[] multibyteBytes = multibyte.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            logger.debug("Multibyte string: {} characters, {} bytes", multibyte.length(), multibyteBytes.length);

            // This tests the SECURITY FIX: byte-based validation should catch oversized data
            if (multibyteBytes.length > blockchain.getMaxBlockSizeBytes()) {
                assertFalse(blockchain.validateBlockSize(multibyte),
                    "Oversized multibyte data should fail byte validation");
            }

            // Test 3: Character count limit should prevent massive character counts
            String manySmallChars = "a".repeat(300000); // 300K ASCII characters (1 byte each)
            assertFalse(blockchain.validateBlockSize(manySmallChars),
                "Excessive character count should fail character validation");
        }

        @Test
        @Order(2)
        @DisplayName("Block size limits should be coherent and secure")
        void testCoherentBlockSizeLimits() {
            int maxBytes = blockchain.getMaxBlockSizeBytes();
            int maxChars = blockchain.getMaxBlockChars();

            // SECURITY FIX verification: Character limit should be consistent with byte limit
            assertTrue(maxChars <= maxBytes,
                "Character limit should not exceed byte limit");

            // Character limit is set for backward compatibility (10K chars)
            // It's intentionally lower than maxBytes/4 to maintain existing behavior
            assertTrue(maxChars > 0 && maxChars <= maxBytes,
                "Character limit should be positive and not exceed byte limit");

            logger.debug("Block size limits - Bytes: {}, Chars: {}", maxBytes, maxChars);
        }
    }

    @Nested
    @DisplayName("ðŸ›¡ï¸ FIX 2: Multi-level Authorization for Dangerous Operations")
    class DangerousOperationAuthorizationFix {

        @Test
        @Order(3)
        @DisplayName("dangerouslyDeleteAuthorizedKey should require valid admin signature")
        void testDangerousDeleteRequiresAdminSignature() {
            // SECURITY FIX: The new method should require admin signature

            // Create a valid signature for the operation
            String reason = "Test deletion";
            String signature = CryptoUtil.createAdminSignature(userPublicKey, false, reason, adminKeyPair.getPrivate());

            // Valid signature should succeed
            boolean result = blockchain.dangerouslyDeleteAuthorizedKey(
                userPublicKey, false, reason, signature, adminPublicKey);
            assertTrue(result, "Valid admin signature should allow dangerous operation");
        }

        @Test
        @Order(4)
        @DisplayName("dangerouslyDeleteAuthorizedKey should reject invalid signatures")
        void testDangerousDeleteRejectsInvalidSignature() {
            String reason = "Test deletion";

            // Test 1: Invalid signature should be rejected
            boolean result1 = blockchain.dangerouslyDeleteAuthorizedKey(
                userPublicKey, false, reason, "invalid-signature", adminPublicKey);
            assertFalse(result1, "Invalid signature should be rejected");

            // Test 2: Signature from non-admin should be rejected
            KeyPair nonAdminKeyPair = CryptoUtil.generateKeyPair();
            String nonAdminPublicKey = CryptoUtil.publicKeyToString(nonAdminKeyPair.getPublic());

            String nonAdminSignature = CryptoUtil.createAdminSignature(userPublicKey, false, reason, nonAdminKeyPair.getPrivate());

            boolean result2 = blockchain.dangerouslyDeleteAuthorizedKey(
                userPublicKey, false, reason, nonAdminSignature, nonAdminPublicKey);
            assertFalse(result2, "Signature from non-authorized key should be rejected");
        }

    }

    @Nested
    @DisplayName("ðŸ”„ FIX 3: Race Condition Prevention in clearAndReinitialize")
    class ClearAndReinitializeRaceConditionFix {

        @Test
        @Order(6)
        @DisplayName("clearAndReinitialize should handle failures gracefully with rollback")
        void testClearAndReinitializeRollbackSafety() {
            // Add some data first
            blockchain.addBlock("Test data 1", userKeyPair.getPrivate(), userKeyPair.getPublic());
            blockchain.addBlock("Test data 2", userKeyPair.getPrivate(), userKeyPair.getPublic());

            long blockCountBefore = blockchain.getBlockCount();
            assertTrue(blockCountBefore > 1, "Should have test data before clear");

            // SECURITY FIX: The method should create a backup and handle failures
            // We test that it completes successfully (rollback would happen on failure)
            assertDoesNotThrow(() -> {
                blockchain.clearAndReinitialize();
            }, "clearAndReinitialize should handle all edge cases gracefully");

            // Verify clean state
            assertEquals(1, blockchain.getBlockCount(), "Should only have genesis block after clear");
        }

        @Test
        @Order(7)
        @DisplayName("clearAndReinitialize should be thread-safe")
        void testClearAndReinitializeThreadSafety() throws InterruptedException {
            // Add some test data
            blockchain.addBlock("Thread safety test", userKeyPair.getPrivate(), userKeyPair.getPublic());

            ExecutorService executor = Executors.newFixedThreadPool(5);
            final boolean[] errors = new boolean[1];

            // Try concurrent clear operations (only one should succeed)
            for (int i = 0; i < 3; i++) {
                executor.submit(() -> {
                    try {
                        blockchain.clearAndReinitialize();
                    } catch (Exception e) {
                        synchronized (errors) {
                            errors[0] = true;
                        }
                        logger.error("Thread safety test error", e);
                    }
                });
            }

            executor.shutdown();
            assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS),
                "All threads should complete within timeout");

            assertFalse(errors[0], "No errors should occur during concurrent operations");
            assertEquals(1, blockchain.getBlockCount(), "Should have clean state after concurrent operations");
        }
    }

    @Nested
    @DisplayName("ðŸ›¤ï¸ FIX 4: Path Traversal Prevention in Export/Import")
    class PathTraversalPreventionFix {

        @Test
        @Order(8)
        @DisplayName("exportChain should reject path traversal attempts")
        void testExportChainRejectsPathTraversal() {
            // Test only actual path traversal attempts (containing ..)
            String[] maliciousPaths = {
                "../../../etc/passwd.json",
                "..\\..\\..\\windows\\system32\\config\\sam.json",
                "test/../../../etc/shadow.json",
                "export/../../../home/user/.ssh/id_rsa.json",
                "data\\..\\..\\Windows\\System32\\config.json"
            };

            for (String maliciousPath : maliciousPaths) {
                boolean result = blockchain.exportChain(maliciousPath);
                assertFalse(result, "Should reject malicious path: " + maliciousPath);
            }
        }

        @Test
        @Order(9)
        @DisplayName("importChain should reject path traversal attempts")
        void testImportChainRejectsPathTraversal() {
            String[] maliciousPaths = {
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "/etc/shadow.json",
                "C:\\Windows\\System32\\config\\SAM.json"
            };

            for (String maliciousPath : maliciousPaths) {
                boolean result = blockchain.importChain(maliciousPath);
                assertFalse(result, "Should reject malicious path: " + maliciousPath);
            }
        }

        @Test
        @Order(10)
        @DisplayName("Export/Import should only allow .json files")
        void testExportImportFileExtensionRestriction() {
            String[] invalidExtensions = {
                "test.txt",
                "test.exe",
                "test.sh",
                "test",
                "test.json.exe"
            };

            for (String invalidFile : invalidExtensions) {
                assertFalse(blockchain.exportChain(invalidFile),
                    "Should reject non-JSON export: " + invalidFile);
                assertFalse(blockchain.importChain(invalidFile),
                    "Should reject non-JSON import: " + invalidFile);
            }

            // Valid JSON file should be accepted for export (if path is safe)
            String validPath = "test-export.json";
            // Test that valid JSON extension is accepted (may still fail on other validations)
            // We're testing that it doesn't fail specifically on extension validation
            assertDoesNotThrow(() -> {
                blockchain.exportChain(validPath);
            }, "Valid JSON path should not fail on extension validation");

            // Clean up test file if it was created
            java.io.File testFile = new java.io.File(validPath);
            if (testFile.exists()) {
                testFile.delete();
            }
        }
    }

    @Nested
    @DisplayName("ðŸ” FIX 5: Secure Logging Implementation")
    class SecureLoggingFix {

        @Test
        @Order(11)
        @DisplayName("Sensitive key information should be hashed in logs")
        void testSensitiveKeyInformationHashing() {
            // SECURITY FIX: The createSafeKeyHash method should hash keys for logging

            // This test verifies that the logging improvements are in place
            // We can't directly test log output, but we can verify the method exists and works

            // Create a valid signature for testing
            String reason = "Test logging";
            String signature = CryptoUtil.createAdminSignature(userPublicKey, false, reason, adminKeyPair.getPrivate());

            // This operation should log hashed keys, not full keys
            assertDoesNotThrow(() -> {
                blockchain.dangerouslyDeleteAuthorizedKey(
                    userPublicKey, false, reason, signature, adminPublicKey);
            }, "Operations with sensitive logging should not throw exceptions");

            // Verify the operation actually worked
            AuthorizedKey deletedKey = blockchain.getAuthorizedKeyByOwner("TestUser");
            assertNull(deletedKey, "Key should be deleted and logged securely");
        }
    }

    @Nested
    @DisplayName("ðŸ§ª Integration Security Tests")
    class IntegrationSecurityTests {

        @Test
        @Order(12)
        @DisplayName("All security fixes should work together")
        void testAllSecurityFixesIntegration() {
            // Test 1: Block size validation with edge cases
            String largeValidData = "Valid data ".repeat(900); // 9900 chars < 10000 limit
            assertTrue(blockchain.validateBlockSize(largeValidData),
                "Valid large data should pass");

            // Test 2: Add blocks with validated data
            assertTrue(blockchain.addBlock(largeValidData, userKeyPair.getPrivate(), userKeyPair.getPublic()),
                "Valid blocks should be added successfully");

            // Test 3: Safe export with proper path
            String exportPath = "security-test-export.json";
            assertTrue(blockchain.exportChain(exportPath),
                "Export with valid path should succeed");

            // Test 4: Verify export file exists and clean up
            File exportFile = new File(exportPath);
            assertTrue(exportFile.exists(), "Export file should be created");
            exportFile.delete(); // Clean up

            // Test 5: Clear and reinitialize with safety
            assertDoesNotThrow(() -> {
                blockchain.clearAndReinitialize();
            }, "Clear and reinitialize should work safely");

            assertEquals(1, blockchain.getBlockCount(), "Should have clean state");
        }

        @Test
        @Order(13)
        @DisplayName("Security fixes should maintain performance")
        void testSecurityFixesPerformance() {
            long startTime = System.currentTimeMillis();

            // Perform various operations to test performance impact
            for (int i = 0; i < 10; i++) {
                String data = "Performance test data " + i;
                assertTrue(blockchain.validateBlockSize(data),
                    "Block size validation should be fast");

                blockchain.addBlock(data, userKeyPair.getPrivate(), userKeyPair.getPublic());
            }

            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;

            // Security fixes should not significantly impact performance
            assertTrue(duration < 10000,
                "Security operations should complete within reasonable time: " + duration + "ms");

            logger.debug("Security test operations completed in: {}ms", duration);
        }
    }
}