package com.rbatllet.blockchain.core;

import com.rbatllet.blockchain.entity.AuthorizedKey;
import com.rbatllet.blockchain.security.UserRole;
import com.rbatllet.blockchain.testutil.GenesisKeyManager;
import com.rbatllet.blockchain.util.CryptoUtil;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.security.KeyPair;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive security tests to verify all vulnerability fixes
 * Tests the security improvements implemented in the Blockchain class
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@DisplayName("ðŸ” Blockchain Security Vulnerability Fixes Verification")
class BlockchainSecurityVulnerabilityFixesTest {

    private static final Logger logger = LoggerFactory.getLogger(BlockchainSecurityVulnerabilityFixesTest.class);

    private Blockchain blockchain;
    private KeyPair bootstrapKeyPair;
    private KeyPair adminKeyPair;
    private KeyPair userKeyPair;
    private String adminPublicKey;
    private String userPublicKey;

    @BeforeEach
    void setUp() throws Exception {
        blockchain = new Blockchain();
        blockchain.clearAndReinitialize();

        // Load bootstrap admin keys (created automatically)
        bootstrapKeyPair = GenesisKeyManager.ensureGenesisKeysExist();

        // Register bootstrap admin in blockchain (RBAC v1.0.6)
        blockchain.createBootstrapAdmin(
            CryptoUtil.publicKeyToString(bootstrapKeyPair.getPublic()),
            "BOOTSTRAP_ADMIN"
        );

        // Create admin and user key pairs
        adminKeyPair = CryptoUtil.generateKeyPair();
        userKeyPair = CryptoUtil.generateKeyPair();
        adminPublicKey = CryptoUtil.publicKeyToString(adminKeyPair.getPublic());
        userPublicKey = CryptoUtil.publicKeyToString(userKeyPair.getPublic());

        // Add admin and user as authorized keys (using bootstrap admin credentials)
        blockchain.addAuthorizedKey(adminPublicKey, "Administrator", bootstrapKeyPair, UserRole.ADMIN);
        blockchain.addAuthorizedKey(userPublicKey, "TestUser", bootstrapKeyPair, UserRole.USER);
    }

    @AfterEach
    void tearDown() {
        blockchain.completeCleanupForTests();
    }

    @Nested
    @DisplayName("ðŸ”’ FIX 1: Block Size Validation Consistency")
    class BlockSizeValidationConsistencyFix {

        @Test
        @Order(1)
        @DisplayName("validateAndDetermineStorage should use consistent byte-based validation")
        void testConsistentBlockSizeValidation() {
            // Test 1: Small data should always pass (returns 1=on-chain or 2=off-chain, not 0=invalid)
            assertTrue(blockchain.validateAndDetermineStorage("Small data") != 0,
                "Small data should pass validation");

            // Test 2: Large multibyte characters should be handled correctly
            String multibyte = "æµ‹è¯•".repeat(100000); // Chinese characters, 3 bytes each
            byte[] multibyteBytes = multibyte.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            logger.debug("Multibyte string: {} characters, {} bytes", multibyte.length(), multibyteBytes.length);

            // This tests the SECURITY FIX: byte-based validation should catch oversized data
            if (multibyteBytes.length > blockchain.getMaxBlockSizeBytes()) {
                assertEquals(0, blockchain.validateAndDetermineStorage(multibyte),
                    "Oversized multibyte data should fail byte validation");
            }

            // Test 3: Data exceeding off-chain threshold should go off-chain
            String largeData = "a".repeat(600000); // 600K ASCII characters (1 byte each = 600KB)
            // Exceeds off-chain threshold (512KB) but within max block size (1MB) - should go off-chain
            assertEquals(2, blockchain.validateAndDetermineStorage(largeData),
                "Data exceeding 512KB threshold should be sent off-chain (result=2)");
        }

        @Test
        @Order(2)
        @DisplayName("Block size limits should be coherent and secure")
        void testCoherentBlockSizeLimits() {
            int maxBytes = blockchain.getMaxBlockSizeBytes();
            int offChainThreshold = blockchain.getOffChainThresholdBytes();

            // SECURITY FIX verification: Off-chain threshold should be less than max block size
            assertTrue(offChainThreshold < maxBytes,
                "Off-chain threshold should be less than max block size");

            // Both limits should be positive
            assertTrue(maxBytes > 0, "Max block size should be positive");
            assertTrue(offChainThreshold > 0, "Off-chain threshold should be positive");

            logger.debug("Block size limits - Max: {} bytes, Off-chain threshold: {} bytes", maxBytes, offChainThreshold);
        }
    }

    @Nested
    @DisplayName("ðŸ›¡ï¸ FIX 2: Multi-level Authorization for Dangerous Operations")
    class DangerousOperationAuthorizationFix {

        @Test
        @Order(3)
        @DisplayName("dangerouslyDeleteAuthorizedKey should require valid admin signature")
        void testDangerousDeleteRequiresAdminSignature() {
            // SECURITY FIX: The new method should require admin signature

            // Ensure the user key exists (in case previous test deleted it)
            if (!blockchain.getAuthorizedKeyDAO().isKeyAuthorized(userPublicKey)) {
                blockchain.addAuthorizedKey(userPublicKey, "TestUser", bootstrapKeyPair, UserRole.USER);
            }

            // Create a valid signature for the operation
            String reason = "Test deletion";
            String signature = CryptoUtil.createAdminSignature(userPublicKey, false, reason, adminKeyPair.getPrivate());

            // Valid signature should succeed
            boolean result = blockchain.dangerouslyDeleteAuthorizedKey(
                userPublicKey, false, reason, signature, adminPublicKey);
            assertTrue(result, "Valid admin signature should allow dangerous operation");
        }

        @Test
        @Order(4)
        @DisplayName("dangerouslyDeleteAuthorizedKey should reject invalid signatures")
        void testDangerousDeleteRejectsInvalidSignature() {
            // Ensure the user key exists (in case previous test deleted it)
            if (!blockchain.getAuthorizedKeyDAO().isKeyAuthorized(userPublicKey)) {
                blockchain.addAuthorizedKey(userPublicKey, "TestUser", bootstrapKeyPair, UserRole.USER);
            }

            String reason = "Test deletion";

            // Test 1: Invalid signature should be rejected (v1.0.6+: throws SecurityException)
            SecurityException exception1 = assertThrows(SecurityException.class, () -> {
                blockchain.dangerouslyDeleteAuthorizedKey(
                    userPublicKey, false, reason, "invalid-signature", adminPublicKey);
            }, "Invalid signature should throw SecurityException");
            assertTrue(exception1.getMessage().contains("SECURITY VIOLATION"),
                "Exception should indicate security violation");

            // Test 2: Signature from non-admin should be rejected (v1.0.6+: throws SecurityException)
            KeyPair nonAdminKeyPair = CryptoUtil.generateKeyPair();
            String nonAdminPublicKey = CryptoUtil.publicKeyToString(nonAdminKeyPair.getPublic());

            String nonAdminSignature = CryptoUtil.createAdminSignature(userPublicKey, false, reason, nonAdminKeyPair.getPrivate());

            SecurityException exception2 = assertThrows(SecurityException.class, () -> {
                blockchain.dangerouslyDeleteAuthorizedKey(
                    userPublicKey, false, reason, nonAdminSignature, nonAdminPublicKey);
            }, "Signature from non-authorized key should throw SecurityException");
            assertTrue(exception2.getMessage().contains("SECURITY VIOLATION"),
                "Exception should indicate security violation");
        }

    }

    @Nested
    @DisplayName("ðŸ”„ FIX 3: Race Condition Prevention in clearAndReinitialize")
    class ClearAndReinitializeRaceConditionFix {

        @Test
        @Order(6)
        @DisplayName("clearAndReinitialize should handle failures gracefully with rollback")
        void testClearAndReinitializeRollbackSafety() {
            // Add some data first
            blockchain.addBlock("Test data 1", userKeyPair.getPrivate(), userKeyPair.getPublic());
            blockchain.addBlock("Test data 2", userKeyPair.getPrivate(), userKeyPair.getPublic());

            long blockCountBefore = blockchain.getBlockCount();
            assertTrue(blockCountBefore > 1, "Should have test data before clear");

            // SECURITY FIX: The method should create a backup and handle failures
            // We test that it completes successfully (rollback would happen on failure)
            assertDoesNotThrow(() -> {
                blockchain.clearAndReinitialize();
            }, "clearAndReinitialize should handle all edge cases gracefully");

            // Verify clean state
            assertEquals(1, blockchain.getBlockCount(), "Should only have genesis block after clear");
        }

        @Test
        @Order(7)
        @DisplayName("clearAndReinitialize should be thread-safe")
        void testClearAndReinitializeThreadSafety() throws InterruptedException {
            // Add some test data
            blockchain.addBlock("Thread safety test", userKeyPair.getPrivate(), userKeyPair.getPublic());

            ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor(); // Java 25 Virtual Threads;
            final boolean[] errors = new boolean[1];

            // Try concurrent clear operations (only one should succeed)
            for (int i = 0; i < 3; i++) {
                executor.submit(() -> {
                    try {
                        blockchain.clearAndReinitialize();
                    } catch (Exception e) {
                        synchronized (errors) {
                            errors[0] = true;
                        }
                        logger.error("Thread safety test error", e);
                    }
                });
            }

            executor.shutdown();
            assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS),
                "All threads should complete within timeout");

            assertFalse(errors[0], "No errors should occur during concurrent operations");
            assertEquals(1, blockchain.getBlockCount(), "Should have clean state after concurrent operations");
        }
    }

    @Nested
    @DisplayName("ðŸ›¤ï¸ FIX 4: Path Traversal Prevention in Export/Import")
    class PathTraversalPreventionFix {

        @Test
        @Order(8)
        @DisplayName("exportChain should reject path traversal attempts")
        void testExportChainRejectsPathTraversal() {
            // Test only actual path traversal attempts (containing ..)
            String[] maliciousPaths = {
                "../../../etc/passwd.json",
                "..\\..\\..\\windows\\system32\\config\\sam.json",
                "test/../../../etc/shadow.json",
                "export/../../../home/user/.ssh/id_rsa.json",
                "data\\..\\..\\Windows\\System32\\config.json"
            };

            for (String maliciousPath : maliciousPaths) {
                SecurityException exception = assertThrows(SecurityException.class, () -> {
                    blockchain.exportChain(maliciousPath);
                }, "Should throw SecurityException for malicious path: " + maliciousPath);
                assertTrue(exception.getMessage().contains("Path traversal attempt detected"),
                    "Exception message should mention path traversal");
            }
        }

        @Test
        @Order(9)
        @DisplayName("importChain should reject path traversal attempts")
        void testImportChainRejectsPathTraversal() {
            // Test path traversal attempts (with "..")
            String[] pathTraversalAttempts = {
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam"
            };

            for (String maliciousPath : pathTraversalAttempts) {
                SecurityException exception = assertThrows(SecurityException.class, () -> {
                    blockchain.importChain(maliciousPath);
                }, "Should throw SecurityException for path traversal: " + maliciousPath);
                assertTrue(exception.getMessage().contains("Path traversal attempt detected"),
                    "Exception message should mention path traversal");
            }

            // Test absolute paths to system files (nonexistent files)
            String[] systemFilePaths = {
                "/etc/shadow.json",
                "C:\\Windows\\System32\\config\\SAM.json"
            };

            for (String systemPath : systemFilePaths) {
                IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
                    blockchain.importChain(systemPath);
                }, "Should throw IllegalArgumentException for nonexistent system file: " + systemPath);
                assertTrue(exception.getMessage().contains("does not exist"),
                    "Exception message should mention file does not exist");
            }
        }

        @Test
        @Order(10)
        @DisplayName("Export/Import should only allow .json files")
        void testExportImportFileExtensionRestriction() {
            String[] invalidExtensions = {
                "test.txt",
                "test.exe",
                "test.sh",
                "test",
                "test.json.exe"
            };

            for (String invalidFile : invalidExtensions) {
                IllegalArgumentException exportException = assertThrows(IllegalArgumentException.class, () -> {
                    blockchain.exportChain(invalidFile);
                }, "Should throw IllegalArgumentException for non-JSON export: " + invalidFile);
                assertTrue(exportException.getMessage().contains("only allowed for .json files"),
                    "Exception message should mention .json restriction");

                IllegalArgumentException importException = assertThrows(IllegalArgumentException.class, () -> {
                    blockchain.importChain(invalidFile);
                }, "Should throw IllegalArgumentException for non-JSON import: " + invalidFile);
                assertTrue(importException.getMessage().contains("only allowed for .json files"),
                    "Exception message should mention .json restriction");
            }

            // Valid JSON file should be accepted for export (if path is safe)
            String validPath = "test-export.json";
            // Test that valid JSON extension is accepted (may still fail on other validations)
            // We're testing that it doesn't fail specifically on extension validation
            assertDoesNotThrow(() -> {
                blockchain.exportChain(validPath);
            }, "Valid JSON path should not fail on extension validation");

            // Clean up test file if it was created
            File testFile = new File(validPath);
            if (testFile.exists()) {
                testFile.delete();
            }
        }
    }

    @Nested
    @DisplayName("ðŸ” FIX 5: Secure Logging Implementation")
    class SecureLoggingFix {

        @Test
        @Order(11)
        @DisplayName("Sensitive key information should be hashed in logs")
        void testSensitiveKeyInformationHashing() {
            // SECURITY FIX: The createSafeKeyHash method should hash keys for logging

            // This test verifies that the logging improvements are in place
            // We can't directly test log output, but we can verify the method exists and works

            // Create a valid signature for testing
            String reason = "Test logging";
            String signature = CryptoUtil.createAdminSignature(userPublicKey, false, reason, adminKeyPair.getPrivate());

            // This operation should log hashed keys, not full keys
            assertDoesNotThrow(() -> {
                blockchain.dangerouslyDeleteAuthorizedKey(
                    userPublicKey, false, reason, signature, adminPublicKey);
            }, "Operations with sensitive logging should not throw exceptions");

            // Verify the operation actually worked
            AuthorizedKey deletedKey = blockchain.getAuthorizedKeyByOwner("TestUser");
            assertNull(deletedKey, "Key should be deleted and logged securely");
        }
    }

    @Nested
    @DisplayName("ðŸ§ª Integration Security Tests")
    class IntegrationSecurityTests {

        @Test
        @Order(12)
        @DisplayName("All security fixes should work together")
        void testAllSecurityFixesIntegration() {
            // Test 1: Block size validation with edge cases
            String largeValidData = "Valid data ".repeat(900); // 9900 chars < 10000 limit
            assertTrue(blockchain.validateAndDetermineStorage(largeValidData) != 0,
                "Valid large data should pass");

            // Test 2: Add blocks with validated data
            assertTrue(blockchain.addBlock(largeValidData, userKeyPair.getPrivate(), userKeyPair.getPublic()),
                "Valid blocks should be added successfully");

            // Test 3: Safe export with proper path
            String exportPath = "security-test-export.json";
            assertTrue(blockchain.exportChain(exportPath),
                "Export with valid path should succeed");

            // Test 4: Verify export file exists and clean up
            File exportFile = new File(exportPath);
            assertTrue(exportFile.exists(), "Export file should be created");
            exportFile.delete(); // Clean up

            // Test 5: Clear and reinitialize with safety
            assertDoesNotThrow(() -> {
                blockchain.clearAndReinitialize();
            }, "Clear and reinitialize should work safely");

            assertEquals(1, blockchain.getBlockCount(), "Should have clean state");
        }

        @Test
        @Order(13)
        @DisplayName("Security fixes should maintain performance")
        void testSecurityFixesPerformance() {
            long startTime = System.currentTimeMillis();

            // Perform various operations to test performance impact
            for (int i = 0; i < 10; i++) {
                String data = "Performance test data " + i;
                assertTrue(blockchain.validateAndDetermineStorage(data) != 0,
                    "Block size validation should be fast");

                blockchain.addBlock(data, userKeyPair.getPrivate(), userKeyPair.getPublic());
            }

            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;

            // Security fixes should not significantly impact performance
            assertTrue(duration < 10000,
                "Security operations should complete within reasonable time: " + duration + "ms");

            logger.debug("Security test operations completed in: {}ms", duration);
        }
    }
}